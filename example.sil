def main() {
    println("Hello, world!");
}

def math {
    def pi 3.14;

    // first-order Taylor series approximation ;)
    def sin(val x f32) -> x;
}

def println(val s str) {
    syscall.outp(s);
}

def fizzbuzz() {
    for val i = 1; i <= 100; i += 1 {
        if i % 15 = 0 {
            println("Fizz Buzz");
        } else i % 3 = 0 {
            println("Fizz");
        } else i % 5 = 0 {
            println("Buzz");
        } else {
            println(i);
        }
    }
}

def Vector type(x: s32, y: s32);

def dot(val a Vector, val b Vector) -> a.x * b.x + a.y * b.y;

def Expr type
    .Add(Expr, Expr)
    .Neg(Expr)
    .Val(s32);

def Stringable type {
    def string() -> String;
}

ext Vector Stringable {
    def string() -> "This is the vector type! Not a value but you can still implement Stringable :P";
}

ext (val v Vector) Stringable {
    def string() -> "(\(v.x), \(v.y))";
}

def Monad type {
    val Self type -> type

    def new[A](A) -> Self(A);
    def[A] (Self(A)) {
        def map[B](A -> Self(B)) -> Self(B);
        def and[B](Self(B)) -> Self(B);
    }
}

def Option[T] type
    .Some(T)
    .None;

ext Option Monad {
    def new[A](val a A) -> Option.Some(A);

    ext[A] (val a Option[A]) {
        def map[B](val b A -> Option[B]) ->
            if Option.Some(val a) = a -> b(a);
            else -> Option.None;

        def and[B](val b Option[B]) ->
            if Option.Some(_) = a -> b;
            else -> Option.None;
    }
}
